package main

import (
	"log"
	"net"
	"database/sql"
    _ "github.com/lib/pq"
    pb "github.com/silverliningco/ahri_grpc/proto"
   
    "google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/grpc"
    "encoding/json"
    "fmt"
)

// DB is a global variable to hold db connection
var DB *sql.DB

// this server has to implment whole the interfaces generated by the protobuf
type server struct {
}

func (*server) EquipmentSearch(req *pb.Search, stream pb.SearchService_EquipmentSearchServer) error {
  

    results := make([]Result, 0)
    // Convert proto.Search in JSON  
    b, err := protojson.Marshal(req)
    if err != nil {
        return err
    }

    // Convert JSON  to Search struct
    var search Search
    if err := json.Unmarshal(b, &search); err != nil {
        panic(err)
    }

    fmt.Println(search)
   
    if search.NominalSize == nil {
        fmt.Println("Load with ManualJ")
        results, err = LoadWithManualJ(
            search.SystemAttributes.HeatedCooled,
            search.SystemAttributes.FuelSource,
            search.SystemAttributes.EnergyDistributionMethod,
            search.OutdoorDC.CoincidentWB,
            search.OutdoorDC.Heating99DB,
            search.OutdoorDC.Cooling01DB,
            search.LoadCalculation.SensibleBTUH,
            search.LoadCalculation.LatentBTUH,
            search.LoadCalculation.HeatingBTUH,
            nil, 
            DB) 
        if err != nil {
		    log.Fatal(err)
        }
       
    }

    if req.GetLoadCalculation() == nil {
        fmt.Println("Load without ManualJ")
        results, err = LoadWithoutManualJ(
            search.SystemAttributes.HeatedCooled,
            search.SystemAttributes.FuelSource,
            search.SystemAttributes.EnergyDistributionMethod,
            search.NominalSize.NominalTons,
            search.NominalSize.HeatingBTUH,
            search.OutdoorDC.CoincidentWB,
            search.OutdoorDC.Heating99DB,
            search.OutdoorDC.Cooling01DB,
            nil, 
            DB) 
                 
    }

    for _, element := range results {
        myCoolingCapacity := int32(element.CoolingCapacity)
        //mySensibleCapacity := int32(element.SensibleCapacity)
        //myLatentCapacity := int32(element.LatentCapacity)
        // element is the element from someSlice for where we are
        myRes := &pb.Result{
                CoolingCapacity: &myCoolingCapacity,
                EER : &element.EER,
                SEER: &element.SEER,
                HSPF: element.HSPF,//nil,
                AFUE: &element.AFUE,
                OutdoorUnitSKU: &element.OutdoorUnitSKU,
                IndoorUnitSKU: &element.IndoorUnitSKU,
                FurnaceSKU: &element.FurnaceSKU,
                NominalCoolingTons: element.NominalCoolingTons,
                SensibleCapacity: nil, //&mySensibleCapacity,
                LatentCapacity: nil, //&myLatentCapacity,
            }
        if err := stream.Send(myRes); err != nil {
		    return err
	    }
    }

    return nil


}

func main() {
    // Database abstraction.
	db, err := sql.Open("postgres", dbConnectionString)
	if err != nil {
		log.Fatal(err)
	}
	DB = db
	defer db.Close()
    
   fmt.Println("Running Server")
    log.SetFlags(log.LstdFlags | log.Lshortfile)

    lis, err := net.Listen("tcp", "0.0.0.0:50051")
	if err != nil {
		log.Fatalf("Failed to listen %v", err)
	}

	// gRPC server
    s := grpc.NewServer()
    
    pb.RegisterSearchServiceServer(s, &server{})

	if err := s.Serve(lis); err != nil {
		log.Fatalf("Failed to serve %v", err)
	}
}
